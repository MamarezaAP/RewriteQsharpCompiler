# RewriteQsharpCompiler
Internally, the Q# compiler creates many of its own features in the IRewriteStep infrastructure. One of the most sought after items that any Q# developer uses in any local build is the process of generating C# code to run the Q# program in a simulated environment - on a classic computer. QDK has an internal step called CSharpGeneration, which is responsible for generating C# simulation code and is nothing more than an IRewriteStep. It is also worth noting that a considerably multi-word, C# production of Q# is actually done with code written in F#. Many other features of the compiler are also based on the rewriting process - document generation, uniformity, replacement of control flow with quantum operations, or integration of environment-specific syntax trees.

The rewrite steps are discovered by the compiler by scanning all loaded sets and following the implementation of the IRewriteStep interface. The corresponding discovered types are then included in the compiler pipeline. For this reason, it is very easy to use a custom rewrite step - it is enough for a rewrite step to be publicly available in one of the referenced collections - regardless of whether it is a project-to-project reference in the user application or a NuGet package reference. Be. For more advanced users, by calling the compiler programmer, I recently introduced a more sophisticated way to control the rewrite process in the Q# compiler. This allows users to type rewrite steps as instant objects or definitions, and to skip the collection scanning discovery process altogether.

The last thing to note is that depending on how the compiler is called, the rewrite process may or may not be on the editing line. They are included during command line build calls, but do not participate in design time construction due to performance reasons. This means that their effects are not visible in the IDE in real time. This is a point to keep in mind - especially when considering the diagnosis you want to take out of the rewrite phase.

In Q#, the ability to view default operations, functions, and its public types. In fact, there is no such access modifier in the language - in fact, there is a lack of an access modifier that can treat a particular caller or type as public. The only access modifier currently available in this language is internal and can be used to hide one type / contact with external consumers Q# code - what other Q# program (in the case of Q #libraries ) And what program is written in a common language such as C#, which integrates quantum features into Q# through contacts. Such an approach to accessing modifiers is more in line with the F# language design (which also uses the default general template) than C# (internal-by-default), and may therefore be something that is needed if needed. Get used to it. From a strong C# background

Let's use the IRewriteStep scalability infrastructure to create a custom approach to accessing modifiers. Instead of choosing between default (public) behavior and having an internal keyword, we want to use contract-based access using the following rules:

If the first letter can be capitalized, it should always be public

If the first letter cannot be capitalized, it must always be internal

Because of the simplicity of this example, we limit ourselves to callers only, but the logic in question can be easily generalized to user-defined types as well. To achieve all this, we create a netstandard2.1 C# library project that points to the quantum compiler.
